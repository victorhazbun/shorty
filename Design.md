## Back of the envelope estimation

Write operation: 100 million URLs are generated per day.

Write operation per second: 100 million / 24 /3600 = 1160

Read operation: Assuming ratio of read operation to write operation is 10:1, read operation per second: 1160 * 10 = 11,600

Assuming the URL shortener service will run for 10 years, this means we must support 100 million * 365 * 10 = 365 billion records.

Assume average URL length is 100.

Storage requirement over 10 years: 365 billion * 100 bytes = 36.5 TB

### API Endpoints

API endpoints facilitate the communication between clients and servers. I designed the APIs REST-style. A URL shortener primary needs two API endpoints.

1.URL shortening. To create a new short URL, a client sends a POST request, which contains one parameter: the original long URL. The API looks like this:

```
POST /url

request parameter: { long: longURLString }
```

returns 

```
{
    "id": 10,
    "short": "9v28s18FX",
    "long": "https://gorails.com/setup/macos/13-ventura",
    "created_at": "2023-10-06T17:22:44.873Z",
    "updated_at": "2023-10-06T17:22:44.873Z"
}

```

2. View long URL from short. To view long URL from corresponding short, a client sends a GET request. The API looks like this:

```
GET /v/:short

```

returns

```
{
    "long": "https://gorails.com/setup/macos/13-ventura"
}
```

### URL shortening

Let us assume the short URL looks like this: tinyurl.com/v/{hashValue}. 
To support the URL shortening use case, we must find a hash function fx that maps a long URL to the *hashValue*.

The hash function must satisfy the following requirements:

Each longURL must be hashed to one hashValue.

Each hashValue can be mapped back to the longURL.

Detailed design for the hash function is discussed in deep dive.

### Data model

In a high-level design, everything could be stored in a hash table. 
This is a good starting point; however, this approach is not feasible for real-world systems as memory resources are limited and expensive. 
A better option is to store <shortURL, longURL> mapping in a relational database. The simplified version of the table contains 3 columns: id, shortURL, longURL.

![Screenshot 2023-10-06 at 12 47 16 PM](https://github.com/victorhazbun/shorty/assets/1174604/352070e0-7d19-44f6-a37e-01be397394a4)

## Hash function

Hash function is used to hash a long URL to a short URL, also known as hashValue.

## Base 62 conversion

Base conversion is an approach commonly used for URL shorteners. 
Base conversion helps to convert the same number between its different number representation systems. 
Base 62 conversion is used as there are 62 possible characters for hashValue. 
Let's use an example to explain how the conversion works: convert 1115710 to base 62 representation (1115710 represents 11157 in a base 10 system).

From its name, base 62 is a way of using 62 characters for encoding. The mappings are: 0-0, ..., 9-9, 10-a, 11-b, ..., 35-z, 36-A, ..., 61-Z, where ‘a’ stands for 10, ‘Z’ stands for 61, etc.

1115710 = 2 x 622 + 55 x 621 + 59 x 620 = [2, 55, 59] -> [2, T, X] in base 62 representation. Figure shows the conversation process.

![Screenshot 2023-10-06 at 1 01 58 PM](https://github.com/victorhazbun/shorty/assets/1174604/88c9bd4d-37ed-42a6-92cc-3640f933d528)

## URL shortening deep dive

As one of the core pieces of the system, we want the URL shortening flow to be logically simple and functional. 
Base 62 conversion is used in our design. We build the following diagram to demonstrate the flow.

![Screenshot 2023-10-06 at 1 06 01 PM](https://github.com/victorhazbun/shorty/assets/1174604/b8e61e7c-a22f-4d85-aa9a-699be28a9690)

1. longURL is the input.
2. The system checks if the longURL is in the database.
3. If it is, it means the longURL was converted to shortURL before. In this case, fetch the shortURL from the database and return it to the client.
4. If not, the longURL is new. A new unique ID is generated by the unique ID generator (snowflake).
5. Convert the ID to shortURL with base 62 conversion.
6. Create a new database row with shortURL, and longURL.

To make the flow easier to understand, let us look at a concrete example.

Assuming the input longURL is: https://en.wikipedia.org/wiki/Systems_design

Snowflake ID generator returns: 6359478865891329.

Convert the ID to shortURL using the base 62 conversion. ID (6359478865891329) is converted to “t7QbSWXCN”.

## Twitter snowflake approach

Twitter’s unique ID generation system called [snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) is inspiring and can satisfy our requirements.

Divide and conquer is our friend. Instead of generating an ID directly, we divide an ID into different sections. Figure shows the layout of a 64-bit ID.

![Screenshot 2023-10-06 at 1 13 31 PM](https://github.com/victorhazbun/shorty/assets/1174604/4c4f9103-f05d-4464-b30c-d49efd8aa8e5)

Each section is explained below.

Sign bit: 1 bit. It will always be 0. This is reserved for future uses. It can potentially be used to distinguish between signed and unsigned numbers.

Timestamp: 41 bits. Milliseconds since the epoch or custom epoch. We use Twitter snowflake default epoch 1288834974657, equivalent to Nov 04, 2010, 01:42:54 UTC.

Datacenter ID: 5 bits, which gives us 2 ^ 5 = 32 datacenters.

Machine ID / Node ID: 5 bits, which gives us 2 ^ 5 = 32 machines per datacenter.

Sequence number: 12 bits. For every ID generated on that machine/process, the sequence number is incremented by 1. The number is reset to 0 every millisecond.

## Get long URL from short URL

Figure shows the detailed design of the URL viewing. As there are more reads than writes, <shortURL, longURL> mapping is stored in a cache to improve performance.

![Screenshot 2023-10-06 at 1 17 39 PM](https://github.com/victorhazbun/shorty/assets/1174604/906217c7-e780-49f9-859f-6e52ef726983)

## The flow of URL view is summarized as follows:

1. A user visits a short URL link: https://tinyurl.com/zn9edcu

2. The load balancer forwards the request to web servers.

3. If a shortURL is already in the cache, return the longURL directly.

4. If a shortURL is not in the cache, fetch the longURL from the database. If it is not in the database, it is likely a user entered an invalid shortURL.

5. The longURL is returned to the user.

## Other considerations

Rate limiter: A potential security problem we could face is that malicious users send an overwhelmingly large number of URL shortening requests. 
Rate limiter helps to filter out requests based on IP address or other filtering rules.

Web server scaling: Since the web tier is stateless, it is easy to scale the web tier by adding or removing web servers.

Database scaling: Database replication and sharding are common techniques.

Analytics: Data is increasingly important for business success. Integrating an analytics solution to the URL shortener could help to answer important questions like how many people click on a link? When do they click the link? etc.
